## Rust Learning Notes



### Rust输出到命令行

- `println!("[格式化字符串]", [变量列表])`
- `print!("[格式化字符串]", [变量列表])`
- 二者的不同仅在于`println!`会加一个换行
- 用`{}`表示占位符，`{[下标]}`访问变量列表的某个下标，`{{}}`表示转义
- `println!`不是函数，而是一个**宏规则**

### Rust基础语法

#### 可变变量与不可变变量

这就牵扯到了 Rust 语言为了高并发安全而做的设计：在语言层面尽量少的让变量的值可以改变。所以 a 的值不可变。但这不意味着 a 不是"变量"（英文中的 variable），官方文档称 a 这种变量为"不可变变量"。

如果我们编写的程序的一部分在假设值永远不会改变的情况下运行，而我们代码的另一部分在改变该值，那么代码的第一部分可能就不会按照设计的意图去运转。由于这种原因造成的错误很难在事后找到。这是 Rust 语言设计这种机制的原因。

变量的值可以"重新绑定"，但在"重新绑定"以前不能私自被改变，这样可以确保在每一次"绑定"之后的区域里编译器可以充分的推理程序逻辑。 

#### 重影（Shadowing）

重影就是刚才讲述的所谓"重新绑定"，之所以加引号就是为了在没有介绍这个概念的时候代替一下概念。

重影就是指变量的名称可以被重新使用的机制。



### Rust数据类型

有的整数中间存在一个下划线，这种设计可以让人们在输入一个很大的数字时更容易判断数字的值大概是多少。

Rust的 char 类型大小为 **4 个字节**，代表 Unicode标量值，这意味着它可以支持中文，日文和韩文字符等非英文字符甚至表情符号和零宽度空格在 Rust 中都是有效的 char 值。



### Rust函数

- Rust 函数体由一系列可以以表达式（Expression）结尾的语句（Statement）组成。
- 表达式有计算步骤且有返回值。以下是表达式（假设出现的标识符已经被定义）：
  ```rust
  a = 7
  b + 2
  c * (a + b)
  ```

#### 表达式&函数体表达式

- Rust 中可以在一个用 **{}** 包括的块里编写一个较为复杂的表达式：

  ```rust
  fn main() {
    let x = 5;
  
    let y = {
      let x = 3;
      x + 1
    };
  
    println!("x 的值为 : {}", x);
    println!("y 的值为 : {}", y);
  }
  ```

- 这段程序中包含了一个表达式块：

  ```rust
  {
      let x = 3;
      x + 1
  };
  ```

  而且在块中可以使用函数语句，最后一个步骤是表达式，此表达式的结果值是整个表达式块所代表的值。这种表达式块叫做**函数体表达式**。

  - 函数体表达式并不能等同于函数体，它不能使用 **return** **关键字。**

  注意：**x + 1** 之后没有分号，否则它将变成一条语句！

  这种表达式块是一个合法的函数体。而且在 Rust 中，函数定义可以嵌套：

  ```rust
  fn main() {
      fn five() -> i32 {
          5
      }
      println!("five() 的值为: {}", five());
  }
  ```

- Rust 不支持自动返回值类型判断。如果没有明确声明函数返回值的类型，函数将被认为是"纯过程"，不允许产生返回值，return 后面不能有返回值表达式。

### Rust所有权

所有权（ownership）是 Rust 语言为高效使用内存而设计的语法机制。

#### 所有权规则

所有权有以下三条规则：

- Rust 中的每个值都有一个变量，称为其所有者。
- 一次只能有一个所有者。
- 当所有者不在程序运行范围时，该值将被删除。

#### “变量”与“值”交互的种类

- 移动
  - 基本类型——栈上
  - 堆上
- 克隆
- 引用与租借
  - 引用：可以是可变引用  `let s2 = &mut s1;`
  - 租借：a的引用暂时获得a的值的所有权
  - 可变引用与不可变引用相比除了权限不同以外，可变引用不允许多重引用，但不可变引用可以（太细了，，，）

#### 函数相关的所有权规则

- 如果将变量当作参数传入函数，那么它和移动的效果是一样的。

- 被当作函数返回值的变量所有权将会被移动出函数并返回到调用函数的地方，而不会直接被无效释放。

### Rust结构体

### 元组结构体

有一种更简单的定义和使用结构体的方式：**元组结构体**。

元组结构体是一种形式是元组的结构体。

与元组的区别是它有名字和固定的类型格式。它存在的意义是为了处理那些需要定义类型（经常使用）又不想太复杂的简单数据：

```rust
struct Color(u8, u8, u8);
struct Point(f64, f64);

let black = Color(0, 0, 0);
let origin = Point(0.0, 0.0);
```

